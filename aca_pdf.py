# aca_pdf.py
from __future__ import annotations

from io import BytesIO
from typing import Dict, List, Optional, Tuple
import pandas as pd
from PyPDF2 import PdfReader, PdfWriter

from debug_logging import get_logger, log_time

log = get_logger("aca_pdf")

# ============================================================
# Excel writer (used by /process/excel)
#   - Accepts BOTH positional and keyword args.
#   - Positional order: interim, final, penalty_dashboard, (optional) workbook_title
#   - Keyword form also supported: save_excel_outputs(interim=..., final=..., penalty_dashboard=..., workbook_title="...")
# ============================================================

def save_excel_outputs(*args, **kwargs) -> bytes:
    """
    Build an Excel workbook (bytes) containing any of the provided DataFrames.

    Accepted call styles:
      1) Keyword:
         save_excel_outputs(interim=df1, final=df2, penalty_dashboard=df3, workbook_title="ACA Outputs")
      2) Positional (legacy):
         save_excel_outputs(df1, df2, df3)                         # title defaults to "ACA Outputs"
         save_excel_outputs(df1, df2, df3, "My Workbook Title")    # explicit title

    Sheet names:
      - "Interim"            (if provided)
      - "Final"              (if provided)
      - "Penalty Dashboard"  (if provided)
    """
    # ---- Parse inputs from args/kwargs (backward-compatible) ----
    interim = kwargs.get("interim", None)
    final = kwargs.get("final", None)
    penalty_dashboard = kwargs.get("penalty_dashboard", None)
    workbook_title = kwargs.get("workbook_title", None)

    # If positional args were supplied, map them in order.
    #   0 -> interim, 1 -> final, 2 -> penalty_dashboard, 3 -> workbook_title (optional)
    if args:
        if len(args) >= 1:
            interim = args[0]
        if len(args) >= 2:
            final = args[1]
        if len(args) >= 3:
            penalty_dashboard = args[2]
        if len(args) >= 4 and workbook_title is None:
            workbook_title = args[3]
        # ignore any extra positional args silently to be lenient

    if workbook_title is None:
        workbook_title = "ACA Outputs"

    if all(x is None for x in (interim, final, penalty_dashboard)):
        raise ValueError("save_excel_outputs: nothing to write")

    # ---- Write Excel to bytes ----
    with log_time(log, "save_excel_outputs"):
        buf = BytesIO()
        with pd.ExcelWriter(buf, engine="xlsxwriter") as xw:
            try:
                xw.book.set_properties({
                    'title': str(workbook_title),
                    'comments': 'Generated by ACA 1095 service',
                })
            except Exception:
                # Older engines might not support set_properties; safe to continue.
                pass

            if isinstance(interim, pd.DataFrame):
                interim.to_excel(xw, sheet_name="Interim", index=False)
            if isinstance(final, pd.DataFrame):
                final.to_excel(xw, sheet_name="Final", index=False)
            if isinstance(penalty_dashboard, pd.DataFrame):
                penalty_dashboard.to_excel(xw, sheet_name="Penalty Dashboard", index=False)

        buf.seek(0)
        return buf.read()

# ============================================================
# PDF mapping & form fill for 1095-C
# ============================================================

# Part I (Employee)
PART1_FIELDS = {
    "first_name": "f1_1",
    "middle_name": "f1_2",
    "last_name": "f1_3",
    "ssn": "f1_4",
    "address1": "f1_5",
    "address2": "f1_6",
    "city": "f1_7",
    "state": "f1_8",
    "zip": "f1_9",
}

# Part II (Monthly Line 14 and Line 16) – template-dependent; adjust if your PDF uses different IDs
LINE14_MONTH_FIELDS = {
    1: "f1_18", 2: "f1_19", 3: "f1_20", 4: "f1_21",
    5: "f1_22", 6: "f1_23", 7: "f1_24", 8: "f1_25",
    9: "f1_26", 10:"f1_27", 11:"f1_28", 12:"f1_29",
}
LINE16_MONTH_FIELDS = {
    1: "f1_44", 2: "f1_45", 3: "f1_46", 4: "f1_47",
    5: "f1_48", 6: "f1_49", 7: "f1_50", 8: "f1_51",
    9: "f1_52", 10:"f1_53", 11:"f1_54", 12:"f1_55",
}

# Part III (Covered Individuals) – up to 9 rows (template-dependent)
PART3_ROW_TEMPLATE = {
    "name": "p3_name_{i}",
    "ssn": "p3_ssn_{i}",
    "all12": "p3_all12_{i}",
    "m1": "p3_m1_{i}", "m2": "p3_m2_{i}", "m3": "p3_m3_{i}",
    "m4": "p3_m4_{i}", "m5": "p3_m5_{i}", "m6": "p3_m6_{i}",
    "m7": "p3_m7_{i}", "m8": "p3_m8_{i}", "m9": "p3_m9_{i}",
    "m10": "p3_m10_{i}", "m11": "p3_m11_{i}", "m12": "p3_m12_{i}",
}
def _part3_fields_map(max_rows: int = 9) -> List[Dict[str, str]]:
    rows = []
    for i in range(1, max_rows + 1):
        rows.append({k: v.format(i=i) for k, v in PART3_ROW_TEMPLATE.items()})
    return rows

def _set_need_appearances(writer: PdfWriter) -> None:
    try:
        # Best-effort: some PyPDF2 versions don’t expose this cleanly; safe to ignore failures.
        pass
    except Exception:
        pass

def _set_form_fields(writer: PdfWriter, field_values: Dict[str, str]) -> None:
    # Many templates only need this call on page 1; if yours is different, loop pages.
    try:
        writer.update_page_form_field_values(writer.pages[0], field_values)
    except Exception:
        # Fallback: ignore if writer cannot update; most common templates work above.
        pass

# ------------------------------------------------------------
# Public: fill a single employee’s PDF
# ------------------------------------------------------------

def fill_pdf_for_employee(
    *,
    blank_pdf_bytes: bytes,
    employee_pi: Dict[str, str],
    line14_by_month: Dict[int, str],
    line16_by_month: Dict[int, str],
    covered_individuals: Optional[List[Dict[str, object]]] = None,
    flatten: bool = True
) -> Tuple[bytes, Optional[bytes]]:
    """
    Fill a 1095-C PDF for one employee.
    - employee_pi: {'first_name','middle_name','last_name','ssn','address1','address2','city','state','zip'}
    - line14_by_month: {1:'1E', ..., 12:'1H'}
    - line16_by_month: {1:'2C', ..., 12:'2A'}
    - covered_individuals: [{'name':'Jane','ssn':'...','months':[1,2,...],'all12':True/False}, ...]
    Returns: (flattened_bytes, editable_bytes or None)
    """
    with log_time(log, "fill_pdf_for_employee"):
        reader = PdfReader(BytesIO(blank_pdf_bytes))
        writer = PdfWriter()
        for page in reader.pages:
            writer.add_page(page)

        field_values: Dict[str, str] = {}

        # Part I
        field_values[PART1_FIELDS["first_name"]]  = employee_pi.get("first_name", "")
        field_values[PART1_FIELDS["middle_name"]] = employee_pi.get("middle_name", "")
        field_values[PART1_FIELDS["last_name"]]   = employee_pi.get("last_name", "")
        field_values[PART1_FIELDS["ssn"]]         = employee_pi.get("ssn", "")
        field_values[PART1_FIELDS["address1"]]    = employee_pi.get("address1", "")
        field_values[PART1_FIELDS["address2"]]    = employee_pi.get("address2", "")
        field_values[PART1_FIELDS["city"]]        = employee_pi.get("city", "")
        field_values[PART1_FIELDS["state"]]       = employee_pi.get("state", "")
        field_values[PART1_FIELDS["zip"]]         = employee_pi.get("zip", "")

        # Part II (Line 14 / Line 16 per month)
        for m in range(1, 13):
            if m in LINE14_MONTH_FIELDS:
                field_values[LINE14_MONTH_FIELDS[m]] = str(line14_by_month.get(m, "") or "")
            if m in LINE16_MONTH_FIELDS:
                field_values[LINE16_MONTH_FIELDS[m]] = str(line16_by_month.get(m, "") or "")

        # Part III (Covered Individuals)
        if covered_individuals:
            part3_fields = _part3_fields_map(9)
            for i, person in enumerate(covered_individuals[:9], start=1):
                f = part3_fields[i - 1]
                name = person.get("name") or ""
                ssn = person.get("ssn") or ""
                all12 = bool(person.get("all12", False))
                months = set(person.get("months") or [])
                field_values[f["name"]] = str(name)
                field_values[f["ssn"]] = str(ssn)
                field_values[f["all12"]] = "Yes" if all12 else ""
                for m in range(1, 13):
                    key = f[f"m{m}"]
                    field_values[key] = "Yes" if (all12 or m in months) else ""

        # Write fields and (optionally) flatten
        _set_form_fields(writer, field_values)
        _set_need_appearances(writer)

        editable_buf = BytesIO()
        writer.write(editable_buf)
        editable_bytes = editable_buf.getvalue()

        if not flatten:
            return editable_bytes, None

        # Flatten by rewriting pages into a new writer
        flat_writer = PdfWriter()
        for page in PdfReader(BytesIO(editable_bytes)).pages:
            flat_writer.add_page(page)
        flat_buf = BytesIO()
        flat_writer.write(flat_buf)
        return flat_buf.getvalue(), editable_bytes
