# aca_pdf.py
from __future__ import annotations

from io import BytesIO
from typing import Dict, List, Optional, Tuple
import pandas as pd
from PyPDF2 import PdfReader, PdfWriter

from debug_logging import get_logger, log_time

log = get_logger("aca_pdf")

# ------------------------------------------------------------
# Excel writer (used by /process/excel)
# ------------------------------------------------------------

def save_excel_outputs(
    *,
    interim: Optional[pd.DataFrame] = None,
    final: Optional[pd.DataFrame] = None,
    penalty_dashboard: Optional[pd.DataFrame] = None,
    workbook_title: str = "ACA Outputs"
) -> bytes:
    """
    Build an Excel workbook (bytes) containing any of the provided DataFrames.
    Sheet names:
      - "Interim"
      - "Final"
      - "Penalty Dashboard"
    All params are optional; at least one must be non-None.
    """
    with log_time(log, "save_excel_outputs"):
        if all(x is None for x in (interim, final, penalty_dashboard)):
            raise ValueError("save_excel_outputs: nothing to write")

        buf = BytesIO()
        with pd.ExcelWriter(buf, engine="xlsxwriter") as xw:
            xw.book.set_properties({
                'title': workbook_title,
                'comments': 'Generated by ACA 1095 service',
            })
            if isinstance(interim, pd.DataFrame):
                interim.to_excel(xw, sheet_name="Interim", index=False)
            if isinstance(final, pd.DataFrame):
                final.to_excel(xw, sheet_name="Final", index=False)
            if isinstance(penalty_dashboard, pd.DataFrame):
                penalty_dashboard.to_excel(xw, sheet_name="Penalty Dashboard", index=False)
        buf.seek(0)
        return buf.read()

# ------------------------------------------------------------
# PDF mapping & form fill for 1095-C
# ------------------------------------------------------------

# Field IDs here are typical AcroForm names; adjust for your template as needed.
# Part I (Employee)
PART1_FIELDS = {
    "first_name": "f1_1",
    "middle_name": "f1_2",
    "last_name": "f1_3",
    "ssn": "f1_4",
    "address1": "f1_5",
    "address2": "f1_6",
    "city": "f1_7",
    "state": "f1_8",
    "zip": "f1_9",
}

# Part II (Monthly Line 14 and Line 16) – common IRS 1095-C layouts use these IDs
LINE14_MONTH_FIELDS = {
    1: "f1_18", 2: "f1_19", 3: "f1_20", 4: "f1_21",
    5: "f1_22", 6: "f1_23", 7: "f1_24", 8: "f1_25",
    9: "f1_26", 10:"f1_27", 11:"f1_28", 12:"f1_29",
}
LINE16_MONTH_FIELDS = {
    1: "f1_44", 2: "f1_45", 3: "f1_46", 4: "f1_47",
    5: "f1_48", 6: "f1_49", 7: "f1_50", 8: "f1_51",
    9: "f1_52", 10:"f1_53", 11:"f1_54", 12:"f1_55",
}

# Part III (Covered Individuals) – up to 9 rows on most templates
# For simplicity we’ll support name + SSN and per-month checkboxes + All 12
PART3_ROW_TEMPLATE = {
    "name": "p3_name_{i}",
    "ssn": "p3_ssn_{i}",
    "all12": "p3_all12_{i}",
    "m1": "p3_m1_{i}", "m2": "p3_m2_{i}", "m3": "p3_m3_{i}",
    "m4": "p3_m4_{i}", "m5": "p3_m5_{i}", "m6": "p3_m6_{i}",
    "m7": "p3_m7_{i}", "m8": "p3_m8_{i}", "m9": "p3_m9_{i}",
    "m10": "p3_m10_{i}", "m11": "p3_m11_{i}", "m12": "p3_m12_{i}",
}
def _part3_fields_map(max_rows: int = 9) -> List[Dict[str, str]]:
    rows = []
    for i in range(1, max_rows+1):
        rows.append({k: v.format(i=i) for k, v in PART3_ROW_TEMPLATE.items()})
    return rows

def _set_need_appearances(writer: PdfWriter) -> None:
    try:
        if writer._root_object is not None:
            writer._root_object.update({
                writer._root_object.indirect_reference.pdf.trailer["/Root"].pdf_name("/NeedAppearances"): True
            })
    except Exception:
        # Fallback for PyPDF2 versions; safe to ignore if not supported
        pass

def _coalesce_name(first: str, middle: str, last: str) -> str:
    parts = [p for p in [first, middle, last] if p]
    return " ".join(parts)

def _set_form_fields(writer: PdfWriter, field_values: Dict[str, str]) -> None:
    try:
        for page in writer.pages:
            pass  # placeholder: PyPDF2 writes values at the document level
        writer.update_page_form_field_values(writer.pages[0], field_values)
    except Exception:
        # Some templates require update at writer level only
        writer.update_page_form_field_values(writer.pages[0], field_values)

def _flatten(reader: PdfReader) -> PdfWriter:
    writer = PdfWriter()
    for page in reader.pages:
        writer.add_page(page)
    # Clear form fields to flatten (appearance streams kept)
    try:
        writer.remove_annotations(writer.pages[0])
    except Exception:
        pass
    return writer

# ------------------------------------------------------------
# Public: fill a single employee’s PDF
# ------------------------------------------------------------

def fill_pdf_for_employee(
    *,
    blank_pdf_bytes: bytes,
    employee_pi: Dict[str, str],
    # month codes for Part II
    line14_by_month: Dict[int, str],
    line16_by_month: Dict[int, str],
    # Part III covered individuals (optional)
    covered_individuals: Optional[List[Dict[str, object]]] = None,
    flatten: bool = True
) -> Tuple[bytes, Optional[bytes]]:
    """
    Fill a 1095-C PDF for one employee.
    - employee_pi: {'first_name','middle_name','last_name','ssn','address1','address2','city','state','zip'}
    - line14_by_month: {1:'1E', ..., 12:'1H'}
    - line16_by_month: {1:'2C', ..., 12:'2A'}
    - covered_individuals: list of dicts:
        {
          'name': 'Jane Doe',
          'ssn': '123-45-6789',
          'months': [1,2,3,...],    # months covered
          'all12': True/False
        }
    Returns: (flattened_bytes, editable_bytes or None)
    """
    with log_time(log, "fill_pdf_for_employee"):
        reader = PdfReader(BytesIO(blank_pdf_bytes))
        writer = PdfWriter()
        for page in reader.pages:
            writer.add_page(page)

        field_values: Dict[str, str] = {}

        # Part I
        field_values[PART1_FIELDS["first_name"]]  = employee_pi.get("first_name", "")
        field_values[PART1_FIELDS["middle_name"]] = employee_pi.get("middle_name", "")
        field_values[PART1_FIELDS["last_name"]]   = employee_pi.get("last_name", "")
        field_values[PART1_FIELDS["ssn"]]         = employee_pi.get("ssn", "")
        field_values[PART1_FIELDS["address1"]]    = employee_pi.get("address1", "")
        field_values[PART1_FIELDS["address2"]]    = employee_pi.get("address2", "")
        field_values[PART1_FIELDS["city"]]        = employee_pi.get("city", "")
        field_values[PART1_FIELDS["state"]]       = employee_pi.get("state", "")
        field_values[PART1_FIELDS["zip"]]         = employee_pi.get("zip", "")

        # Part II (Line 14 / Line 16 per month)
        for m in range(1, 13):
            if m in LINE14_MONTH_FIELDS:
                field_values[LINE14_MONTH_FIELDS[m]] = str(line14_by_month.get(m, "") or "")
            if m in LINE16_MONTH_FIELDS:
                field_values[LINE16_MONTH_FIELDS[m]] = str(line16_by_month.get(m, "") or "")

        # Part III (Covered Individuals)
        if covered_individuals:
            part3_fields = _part3_fields_map(9)
            for i, person in enumerate(covered_individuals[:9], start=1):
                f = part3_fields[i-1]
                name = person.get("name") or ""
                ssn  = person.get("ssn") or ""
                all12 = bool(person.get("all12", False))
                months = set(person.get("months") or [])
                field_values[f["name"]] = str(name)
                field_values[f["ssn"]]  = str(ssn)
                field_values[f["all12"]] = "Yes" if all12 else ""
                for m in range(1, 13):
                    key = f[f"m{m}"]
                    field_values[key] = "Yes" if (all12 or m in months) else ""

        # Write form fields
        _set_form_fields(writer, field_values)
        _set_need_appearances(writer)

        editable_bytes = None
        out_buf = BytesIO()
        writer.write(out_buf)
        editable_bytes = out_buf.getvalue()

        if not flatten:
            return editable_bytes, None

        # Flatten
        flat_writer = PdfWriter()
        for page in PdfReader(BytesIO(editable_bytes)).pages:
            flat_writer.add_page(page)
        flat_buf = BytesIO()
        flat_writer.write(flat_buf)
        return flat_buf.getvalue(), editable_bytes
