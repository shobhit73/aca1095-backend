# aca_pdf.py
from __future__ import annotations

from io import BytesIO
from typing import Dict, List, Optional, Tuple
import pandas as pd
from PyPDF2 import PdfReader, PdfWriter

from debug_logging import get_logger, log_time

log = get_logger("aca_pdf")

# ============================================================
# Excel writer (used by /process/excel)
#   - Accepts BOTH positional and keyword args.
#   - Positional order: interim, final, penalty_dashboard, (optional) workbook_title
#   - Keyword form also supported.
#   - Writes sheets even when a DataFrame is empty.
# ============================================================

def save_excel_outputs(*args, **kwargs) -> bytes:
    """
    Build an Excel workbook (bytes) containing any of the provided DataFrames.

    Accepted call styles:
      1) Keyword:
         save_excel_outputs(interim=df1, final=df2, penalty_dashboard=df3, workbook_title="ACA Outputs")
      2) Positional (legacy):
         save_excel_outputs(df1, df2, df3)                         # title defaults to "ACA Outputs"
         save_excel_outputs(df1, df2, df3, "My Workbook Title")    # explicit title

    Sheet names:
      - "Interim"            (if provided, even if empty)
      - "Final"              (if provided, even if empty)
      - "Penalty Dashboard"  (if provided, even if empty)
    """
    # Parse inputs from args/kwargs (backward-compatible)
    interim = kwargs.get("interim", None)
    final = kwargs.get("final", None)
    penalty_dashboard = kwargs.get("penalty_dashboard", None)
    workbook_title = kwargs.get("workbook_title", None)

    # If positional args were supplied, map them in order.
    if args:
        if len(args) >= 1:
            interim = args[0]
        if len(args) >= 2:
            final = args[1]
        if len(args) >= 3:
            penalty_dashboard = args[2]
        if len(args) >= 4 and workbook_title is None:
            workbook_title = args[3]
        # silently ignore extra positionals

    if workbook_title is None:
        workbook_title = "ACA Outputs"

    if all(x is None for x in (interim, final, penalty_dashboard)):
        raise ValueError("save_excel_outputs: nothing to write")

    with log_time(log, "save_excel_outputs"):
        buf = BytesIO()
        with pd.ExcelWriter(buf, engine="xlsxwriter") as xw:
            try:
                xw.book.set_properties({
                    'title': str(workbook_title),
                    'comments': 'Generated by ACA 1095 service',
                })
            except Exception:
                pass

            if isinstance(interim, pd.DataFrame):
                interim.to_excel(xw, sheet_name="Interim", index=False)
            if isinstance(final, pd.DataFrame):
                final.to_excel(xw, sheet_name="Final", index=False)
            if isinstance(penalty_dashboard, pd.DataFrame):
                penalty_dashboard.to_excel(xw, sheet_name="Penalty Dashboard", index=False)

        buf.seek(0)
        return buf.read()

# ============================================================
# PDF mapping & form fill for 1095-C
#   - Accepts BOTH positional and keyword args.
#   - Positional order:
#       (blank_pdf_bytes, employee_pi, line14_by_month, line16_by_month, covered_individuals=None, flatten=True)
# ============================================================

# Part I (Employee) – adjust these IDs to your template if needed
PART1_FIELDS = {
    "first_name": "f1_1",
    "middle_name": "f1_2",
    "last_name": "f1_3",
    "ssn": "f1_4",
    "address1": "f1_5",
    "address2": "f1_6",
    "city": "f1_7",
    "state": "f1_8",
    "zip": "f1_9",
}

# Part II (Monthly Line 14 and Line 16) – template-dependent
LINE14_MONTH_FIELDS = {
    1: "f1_18", 2: "f1_19", 3: "f1_20", 4: "f1_21",
    5: "f1_22", 6: "f1_23", 7: "f1_24", 8: "f1_25",
    9: "f1_26", 10: "f1_27", 11: "f1_28", 12: "f1_29",
}
LINE16_MONTH_FIELDS = {
    1: "f1_44", 2: "f1_45", 3: "f1_46", 4: "f1_47",
    5: "f1_48", 6: "f1_49", 7: "f1_50", 8: "f1_51",
    9: "f1_52", 10: "f1_53", 11: "f1_54", 12: "f1_55",
}

# Part III (Covered Individuals) – up to 9 rows (template-dependent)
PART3_ROW_TEMPLATE = {
    "name": "p3_name_{i}",
    "ssn": "p3_ssn_{i}",
    "all12": "p3_all12_{i}",
    "m1": "p3_m1_{i}", "m2": "p3_m2_{i}", "m3": "p3_m3_{i}",
    "m4": "p3_m4_{i}", "m5": "p3_m5_{i}", "m6": "p3_m6_{i}",
    "m7": "p3_m7_{i}", "m8": "p3_m8_{i}", "m9": "p3_m9_{i}",
    "m10": "p3_m10_{i}", "m11": "p3_m11_{i}", "m12": "p3_m12_{i}",
}
def _part3_fields_map(max_rows: int = 9) -> List[Dict[str, str]]:
    rows = []
    for i in range(1, max_rows + 1):
        rows.append({k: v.format(i=i) for k, v in PART3_ROW_TEMPLATE.items()})
    return rows

def _set_need_appearances(_writer: PdfWriter) -> None:
    # Best-effort hint; many modern readers ignore this anyway.
    try:
        pass
    except Exception:
        pass

def _set_form_fields(writer: PdfWriter, field_values: Dict[str, str]) -> None:
    # Most templates are fine with updating page 1 only.
    try:
        writer.update_page_form_field_values(writer.pages[0], field_values)
    except Exception:
        pass


def fill_pdf_for_employee(*args, **kwargs) -> Tuple[bytes, Optional[bytes]]:
    """
    Fill a 1095-C PDF for one employee.

    Positional order supported:
      (blank_pdf_bytes, employee_pi, line14_by_month, line16_by_month, covered_individuals=None, flatten=True)

    Keyword args supported:
      blank_pdf_bytes: bytes
      employee_pi: Dict[str,str]
      line14_by_month: Dict[int,str]
      line16_by_month: Dict[int,str]
      covered_individuals: Optional[List[{'name','ssn','months':[...], 'all12':bool}]]
      flatten: bool
    """
    # Parse positional/keyword inputs
    blank_pdf_bytes = kwargs.get("blank_pdf_bytes", None)
    employee_pi = kwargs.get("employee_pi", None)
    line14_by_month = kwargs.get("line14_by_month", None)
    line16_by_month = kwargs.get("line16_by_month", None)
    covered_individuals = kwargs.get("covered_individuals", None)
    flatten = kwargs.get("flatten", True)

    if args:
        if len(args) >= 1: blank_pdf_bytes = args[0]
        if len(args) >= 2: employee_pi = args[1]
        if len(args) >= 3: line14_by_month = args[2]
        if len(args) >= 4: line16_by_month = args[3]
        if len(args) >= 5: covered_individuals = args[4]
        if len(args) >= 6: flatten = args[5]

    if blank_pdf_bytes is None or employee_pi is None or line14_by_month is None or line16_by_month is None:
        raise ValueError("fill_pdf_for_employee: required arguments missing (pdf, employee_pi, line14_by_month, line16_by_month)")

    with log_time(log, "fill_pdf_for_employee"):
        reader = PdfReader(BytesIO(blank_pdf_bytes))
        writer = PdfWriter()
        for page in reader.pages:
            writer.add_page(page)

        field_values: Dict[str, str] = {}

        # Part I
        field_values[PART1_FIELDS["first_name"]]  = str(employee_pi.get("first_name", "") or "")
        field_values[PART1_FIELDS["middle_name"]] = str(employee_pi.get("middle_name", "") or "")
        field_values[PART1_FIELDS["last_name"]]   = str(employee_pi.get("last_name", "") or "")
        field_values[PART1_FIELDS["ssn"]]         = str(employee_pi.get("ssn", "") or "")
        field_values[PART1_FIELDS["address1"]]    = str(employee_pi.get("address1", "") or "")
        field_values[PART1_FIELDS["address2"]]    = str(employee_pi.get("address2", "") or "")
        field_values[PART1_FIELDS["city"]]        = str(employee_pi.get("city", "") or "")
        field_values[PART1_FIELDS["state"]]       = str(employee_pi.get("state", "") or "")
        field_values[PART1_FIELDS["zip"]]         = str(employee_pi.get("zip", "") or "")

        # Part II (Line 14 / Line 16 per month)
        for m in range(1, 13):
            if m in LINE14_MONTH_FIELDS:
                field_values[LINE14_MONTH_FIELDS[m]] = str((line14_by_month.get(m) if isinstance(line14_by_month, dict) else "") or "")
            if m in LINE16_MONTH_FIELDS:
                field_values[LINE16_MONTH_FIELDS[m]] = str((line16_by_month.get(m) if isinstance(line16_by_month, dict) else "") or "")

        # Part III (Covered Individuals) – optional
        if covered_individuals:
            part3_fields = _part3_fields_map(9)
            for i, person in enumerate(covered_individuals[:9], start=1):
                f = part3_fields[i - 1]
                name = person.get("name") or ""
                ssn  = person.get("ssn") or ""
                all12 = bool(person.get("all12", False))
                months = set(person.get("months") or [])
                field_values[f["name"]] = str(name)
                field_values[f["ssn"]]  = str(ssn)
                field_values[f["all12"]] = "Yes" if all12 else ""
                for m in range(1, 13):
                    key = f[f"m{m}"]
                    field_values[key] = "Yes" if (all12 or m in months) else ""

        # Write fields and (optionally) flatten
        try:
            writer.update_page_form_field_values(writer.pages[0], field_values)
        except Exception:
            _set_form_fields(writer, field_values)
        _set_need_appearances(writer)

        editable_buf = BytesIO()
        writer.write(editable_buf)
        editable_bytes = editable_buf.getvalue()

        if not flatten:
            return editable_bytes, None

        # Flatten by rewriting pages into a new writer
        flat_writer = PdfWriter()
        for page in PdfReader(BytesIO(editable_bytes)).pages:
            flat_writer.add_page(page)
        flat_buf = BytesIO()
        flat_writer.write(flat_buf)
        return flat_buf.getvalue(), editable_bytes
