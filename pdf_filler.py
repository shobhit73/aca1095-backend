# pdf_filler.py
# Fill the 1095-C PDF template from the interim DataFrame.
# - Honors /AcroForm/NeedAppearances (so values render)
# - Uses field names from a JSON mapping file
# - Supports BULK or single employee via generate_all_pdfs()

from __future__ import annotations

import io
import json
from typing import Dict, List, Optional, Tuple

import pandas as pd
from PyPDF2 import PdfReader, PdfWriter
from PyPDF2.generic import NameObject, BooleanObject, DictionaryObject, TextStringObject


MONTHS_LABELS = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"]


# ---------- PDF appearance helpers ----------

def enable_need_appearances(reader: PdfReader, writer: PdfWriter) -> None:
    """
    Ensure form field appearances are generated by viewers:
    - /AcroForm/NeedAppearances true
    - Provide /DA (default appearance) and /DR (default resources) fallback
    """
    try:
        root = reader.trailer.get("/Root")
        root = getattr(root, "get_object", lambda: root)()
        if root is None:
            return
        acro = root.get("/AcroForm")
        acro = getattr(acro, "get_object", lambda: acro)()
        if acro is None:
            acro = DictionaryObject()

        acro.update({NameObject("/NeedAppearances"): BooleanObject(True)})

        if "/DA" not in acro:
            # Helvetica, 0 pt (viewer decides), black color
            acro[NameObject("/DA")] = TextStringObject("/Helv 0 Tf 0 g")
        if "/DR" not in acro:
            acro[NameObject("/DR")] = DictionaryObject()

        writer._root_object.update({NameObject("/AcroForm"): acro})
    except Exception:
        pass


def _set_field(writer: PdfWriter, field_name: Optional[str], value: str) -> None:
    if not field_name:
        return
    try:
        writer.update_page_form_field_values(writer.pages[0], {field_name: value})
    except Exception:
        # try trimmed fallback
        try:
            writer.update_page_form_field_values(writer.pages[0], {field_name.strip(): value})
        except Exception:
            pass


# ---------- mapping helpers ----------

def _safe_get(mapping: Dict, *keys, default=None):
    """Deep get: _safe_get(m, 'a','b','c') -> m['a']['b']['c'] or default."""
    cur = mapping
    try:
        for k in keys:
            if cur is None:
                return default
            cur = cur.get(k)
        return cur if cur is not None else default
    except Exception:
        return default


def _month_to_field(mapping: Dict, section: str, line: str, mon_lbl: str) -> Optional[str]:
    """
    Example JSON layout expected (flexible names are fine):
    {
      "part1": { "employee_first_name": "f1_1[0]", "ssn": "f1_4[0]", ... },
      "part2": {
        "line14": {"Jan":"L14_Jan", "Feb":"L14_Feb", ...},
        "line16": {"Jan":"L16_Jan", "Feb":"L16_Feb", ...}
      }
    }
    """
    return _safe_get(mapping, section, line, mon_lbl)


# ---------- main filler ----------

def _name_from_demo(demo_row: pd.Series) -> Dict[str, str]:
    if demo_row is None or not isinstance(demo_row, pd.Series):
        return {}
    return {
        "first": str(demo_row.get("FirstName") or "").strip(),
        "middle": str(demo_row.get("MiddleInitial") or "").strip(),
        "last": str(demo_row.get("LastName") or "").strip(),
        "ssn": str(demo_row.get("SSN") or "").strip(),
        "ein": str(demo_row.get("EIN") or "").strip(),
        "employer_name": str(demo_row.get("EmployerName") or "").strip(),
        "employer_address": str(demo_row.get("EmployerAddress") or "").strip(),
        "employer_city": str(demo_row.get("EmployerCity") or "").strip(),
        "employer_state": str(demo_row.get("EmployerState") or "").strip(),
        "employer_zip": str(demo_row.get("EmployerZipCode") or "").strip(),
    }


def _pick_demo_row(demo_df: Optional[pd.DataFrame], emp_id: int) -> Optional[pd.Series]:
    if demo_df is None or demo_df.empty or "EmployeeID" not in demo_df.columns:
        return None
    sub = demo_df.loc[demo_df["EmployeeID"] == emp_id]
    if sub.empty:
        return None
    # choose row with latest StatusEndDate if available
    if "StatusEndDate" in sub.columns:
        sub = sub.sort_values("StatusEndDate").tail(1)
    return sub.iloc[0]


def _collect_month_codes(interim_df: pd.DataFrame, emp_id: int, year: int) -> Dict[str, Dict[str, str]]:
    """
    Return: {"line14": {"Jan":"1E", ...}, "line16": {"Jan":"2C", ...}}
    """
    out = {"line14": {}, "line16": {}}
    rows = interim_df[(interim_df["Employee_ID"] == emp_id) & (interim_df["Year"] == year)]
    if rows.empty:
        return out
    for mon in MONTHS_LABELS:
        r = rows.loc[rows["Month"] == mon]
        if not r.empty:
            out["line14"][mon] = str(r.iloc[0]["line_14"])
            out["line16"][mon] = str(r.iloc[0]["line_16"])
    return out


def generate_all_pdfs(
    interim_df: pd.DataFrame,
    year: int,
    template_path: str,
    fields_json_path: str,
    demo_df: Optional[pd.DataFrame] = None,
    dep_df: Optional[pd.DataFrame] = None,
) -> List[Tuple[str, bytes]]:
    """
    Build one PDF per employee based on interim_df month codes.
    Returns: list of (filename, pdf_bytes)
    """
    # load mapping
    with open(fields_json_path, "r", encoding="utf-8") as f:
        fields_map: Dict = json.load(f)

    # which employees?
    emp_ids = sorted(set(interim_df["Employee_ID"].tolist()))

    results: List[Tuple[str, bytes]] = []

    for emp_id in emp_ids:
        # prepare PDF writer with appearance flags
        reader = PdfReader(template_path)
        writer = PdfWriter()
        for p in reader.pages:
            writer.add_page(p)
        enable_need_appearances(reader, writer)

        # Part I (top) – fill from demo if present
        demo_row = _pick_demo_row(demo_df, emp_id)
        nm = _name_from_demo(demo_row)

        _set_field(writer, _safe_get(fields_map, "part1", "employee_first_name"), nm.get("first", ""))
        _set_field(writer, _safe_get(fields_map, "part1", "employee_middle_name"), nm.get("middle", ""))
        _set_field(writer, _safe_get(fields_map, "part1", "employee_last_name"), nm.get("last", ""))
        _set_field(writer, _safe_get(fields_map, "part1", "employee_ssn"), nm.get("ssn", ""))

        # Employer info (if the template includes these)
        _set_field(writer, _safe_get(fields_map, "part1", "employer_ein"), nm.get("ein", ""))
        _set_field(writer, _safe_get(fields_map, "part1", "employer_name"), nm.get("employer_name", ""))
        _set_field(writer, _safe_get(fields_map, "part1", "employer_address"), nm.get("employer_address", ""))
        _set_field(writer, _safe_get(fields_map, "part1", "employer_city"), nm.get("employer_city", ""))
        _set_field(writer, _safe_get(fields_map, "part1", "employer_state"), nm.get("employer_state", ""))
        _set_field(writer, _safe_get(fields_map, "part1", "employer_zip"), nm.get("employer_zip", ""))

        # Part II (Line 14 & Line 16 per month) – fill from interim month codes
        codes = _collect_month_codes(interim_df, emp_id, year)
        for mon in MONTHS_LABELS:
            l14_field = _month_to_field(fields_map, "part2", "line14", mon)
            l16_field = _month_to_field(fields_map, "part2", "line16", mon)
            if l14_field:
                _set_field(writer, l14_field, codes["line14"].get(mon, ""))
            if l16_field:
                _set_field(writer, l16_field, codes["line16"].get(mon, ""))

        # Optional Part III (dependents) – only if your mapping contains it
        # Here we simply tick all checkboxes if mapping says "tick_all"
        if "part3" in fields_map:
            p3 = fields_map["part3"]
            if isinstance(p3, dict) and p3.get("tick_all") and "boxes" in p3:
                for field_name in p3["boxes"]:
                    _set_field(writer, field_name, "Yes")

        # Turn off NeedAppearances after setting values; many viewers will keep static appearances
        try:
            acro = writer._root_object.get("/AcroForm")
            acro = getattr(acro, "get_object", lambda: acro)()
            if acro is not None:
                acro.update({NameObject("/NeedAppearances"): BooleanObject(False)})
        except Exception:
            pass

        # Save buffer
        buf = io.BytesIO()
        writer.write(buf)
        buf.seek(0)
        results.append((f"{emp_id}_{year}_1095C.pdf", buf.getvalue()))

    return results
